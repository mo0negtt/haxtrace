Prompt — Corregir curvaturas: límite, export invertido y arco >180° Objetivo

Forzar que todas las curvaturas (campo curve) se limiten a ±340.
Al exportar, invertir el signo de todas las curvaturas (multiplicar por -1) para evitar bugs en editores externos.
Corregir renderer/hit-test para que arcos con |curve|>180° se dibujen correctamente (no «retrocedan» o inviertan el arco), usando cálculo geométrico de arco circular exacto.
Cambios a implementar (por archivo)

Validación y clamp en la UI / creación de segmentos
Archivos: main.js, uiManager.js, mapData.js
Reglas:
Cada vez que se establezca/edite una curva (input numérico, slider, drag de segmento, creación de segmento) clamar el valor: curve = Math.max(-340, Math.min(340, curve));
Asegurar que los controles numéricos/slider tengan min=-340, max=340.
En los handlers de arrastre que calculan rawCurveChange, antes de asignar al segmento hacer clamp y redondeo.
Export: invertir signo de curvas
Archivo: importExport.js
Requisito:
En exportMap() convertir todas las curvas antes de serializar: if (exportData.segments) exportData.segments.forEach(s => { if (s.curve !== undefined) s.curve = -s.curve; });
Preferible: hacer clamp a ±340 justo antes de invertir para evitar valores extremos.
Documentar en UI (tooltip / nota) que export invierte signos por compatibilidad.
Import: (opcional) decidir convención
Archivo: importExport.js
Opciones:
a) Si ya invertías al importar, mantener / ajustar según export.
b) Mejor: añadir preferencia “Invertir curvas al importar/exportar” en Preferences; por ahora aplicar inversión al export sólo (mínimo viable).
Renderer: cálculo correcto de arco circular y handling para |curve|>180°
Archivo: renderer.js (y funciones relacionadas en main.js como getCurvePoints/getSegmentAt si usan aproximaciones)
Problema actual: la representación y/o hit-test usa aproximación Bezier o aplica sentido/anticlockwise incorrecto cuando el ángulo > 180°, lo que hace que el arco visual «salte» o invierta.
Reemplazar/ajustar la lógica de curva por esta guía:
Interpretación: curve representa el ángulo subtendido en grados (signed). Convertir a radianes: angleRad = curve * Math.PI / 180;
Normalizar angleRad a rango (-2π, 2π) o similar para estabilidad; si |curve| >= 360 - epsilon tratar como línea recta.
Calcular distancia chord = distancia entre v0 y v1 (d).
Si |angleRad| < EPSILON -> dibujar línea recta.
Para arco circular:
arcAngle = Math.abs(angleRad) (magnitud)
radius = d / (2 * Math.sin(arcAngle / 2));
Validar divisor ≠ 0; si arcAngle ≈ 0 o ≈ 2π, evitar NaN; clamp arcAngle dentro de (0.001, 2π-0.001).
h = radius * Math.cos(arcAngle / 2) // distancia desde midpoint al centro
midpoint = (v0 + v1) / 2
compute perpendicular unit vector (nx, ny) = normalize( -dy, dx )
center = midpoint + nx * h * sign(curve) // use sign to place center to correct side
startAngle = atan2(v0.y - center.y, v0.x - center.x)
endAngle = atan2(v1.y - center.y, v1.x - center.x)
anticlockwise = curve > 0 ? false/true? <-- careful: determine anticlockwise so the arc drawn matches the signed angle:
To draw the arc that subtends the signed angle, compute delta = normalizeAngle(endAngle - startAngle) in (-π, π] or (-2π,2π) depending, then decide anticlockwise so that the swept angle matches angleRad sign.
Implementation note: for arc angles > π (180°) you must draw the major arc. Canvas arc(center, radius, start, end, anticlockwise) draws the arc from start to end following anticlockwise flag. To draw the arc with magnitude arcAngle (which may be >π), set anticlockwise appropriately or swap start/end to match the intended sweep.
Simpler robust approach:
Compute desired endAngleTarget = startAngle + angleRad (note: angleRad signed).
Normalize endAngleTarget to -π..π or standard.
Then call ctx.arc(centerX, centerY, radius*zoom, startAngle, endAngleTarget, angleRad < 0); // anticlockwise true when angleRad < 0 (depending sign conventions). Test and invert if necessary.
This avoids manual delta logic and ensures even large angles are drawn as intended.
Hit-test:
For selection use exact geometric test: compute distance from point to circle center (abs(hypot(px-center.x,py-center.y) - radius) < threshold) AND check that angle between start and end includes the point angle (in same sweep).
Alternatively fallback to dense sampling only when needed.
getCurvePoints / getSegmentAt: replace Bezier sampling by exact arc sampling
Archivo: main.js (getCurvePoints, getSegmentAt)
Ajuste:
If segment.curve is nonzero, sample points along the exact arc computed above (divide the signed sweep angle into N steps and compute points with center+radius*(cos, sin) for each t).
Use those sample points for hit testing or draw a geometric hit-test as in (4).
Edge cases / numeric stability
Clamp arcAngle to [0.001 rad, 2π - 0.001].
If radius becomes extremely large (near straight line), fallback to drawing straight line.
When computing perpendicular vector, handle zero-length chords safely.
UI / UX notes
Update tooltips/labels to show max curve 340°.
When user drags curve and the value crosses ±180°, visually show preview of arc direction and indicate that >180 uses the major arc (and thus may look inverted compared to small-angle expectation).
Add small helper text in Curve editor: "Curva en grados (±340). Si |curve|>180 se dibuja el arco mayor."
Tests y criterios de aceptación
Test 1: set a segment with curve = 340 and curve = -340; ensure renderer draws arcs (not straight) and export inverts sign (so .hbs has -340 and 340 respectivamente).
Test 2: set curve = 200° and curve = 220° and observe that arcs are correct (no visual flip or backward path); verify that start→end sweep direction corresponds to sign.
Test 3: set curve = 180 and curve = -180; ensure consistent result and no NaN/exception.
Test 4: Hit-test: clicking near arc selects the segment at all angles, including >180.
Test 5: Export the map and open in target editor/game; curves appear correctly (or if still mismatch, inspect sign and adjust import/export invert flag).
Resumen rápido de acciones a aplicar (lista corta)

Clamp curve values to ±340 everywhere.
In importExport.exportMap() invert sign for every segment.curve just before serializing.
Rewrite renderer arc calculation to compute center/radius and draw arc using startAngle + angleRad target (handles |curve|>180).
Replace Bezier-based getCurvePoints with exact arc sampling or geometric hit-test.
Add UI hints and ensure inputs enforce min/max.